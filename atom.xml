<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[lizhijiang's blog]]></title>
  <subtitle><![CDATA[Talk is cheap, show me the code.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="www.zhijiang.me/"/>
  <updated>2015-12-02T11:41:58.000Z</updated>
  <id>www.zhijiang.me/</id>
  
  <author>
    <name><![CDATA[lizhijiang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[To Kobe]]></title>
    <link href="www.zhijiang.me/2015/11/30/For-Kobe/"/>
    <id>www.zhijiang.me/2015/11/30/For-Kobe/</id>
    <published>2015-11-30T11:28:40.000Z</published>
    <updated>2015-12-02T11:41:58.000Z</updated>
    <content type="html"><![CDATA[<p>2013年夏天，NBA官方宣布中国赛将会在当年的10月份举行，分别有北京站和上海站共两场，湖人vs勇士。</p>
<p>那个时候大部分人还没想到勇士会达到今天的成就，但是似乎对湖人的衰落已经有所预感。</p>
<p>那一年魔兽来了又走了，纳什还未能从伤病中恢复过来，家嫂对湖人若即若离，而你，在几个月前跟腱断裂，仍然未能上场比赛。</p>
<p>然而这未能阻止那时刚刚毕业的我，买了一张接近山顶位置的票，从广州出发去到上海，并早早去到球馆检票进场。因为我相信，以你的个性，肯定会出现在赛前热身当中。</p>
<p>进场后坐下，看到库里先从勇士更衣室走出来投三分热身了，那年他还没能进全明星。湖人这边也陆续有球员出来投篮热身。果然，过了不久，球员通道附近的观众开始欢呼，你慢跑着从更衣室到了球场。全场都兴奋起来，开始齐整的叫着口号，似乎忘记了其实你并不能上场比赛。</p>
<p>你在场上待了足够长的时间，那边半场库里的三分在不停的进，伊戈还跟新人还玩起了大风车，而你只是简单地运球，投篮，半场折返跑。你还没有恢复过来，你不能起跳，不能扣篮，你甚至不能做招牌的fade away。我记得我那时候在想，一个人在受到如此严重的伤病之后，需要多大的努力，克服多大的困难，才能让自己重新回到赛场？也许只有你知道答案。终于，比赛开始的哨声响起，你慢慢的走回了更衣室，那时我看着你的背影，真有一点伤感。</p>
<p>到了今天，你宣布到了赛季结束便要退役。大家似乎已经有所准备却还是出乎意料。你说你今年打得太烂，你说你的身体已经无法继续比赛。原来真的有这么一天，你会你离开你所热爱的事物，并非热情退却，只是无能为力。</p>
<p>如果能再给我一次机会，让时间回到2013年的那个夏天，我一定尽我所能，买一张离你最近的票，安安静静的坐在场边，看着你，和那个对你来说二十年如一日的篮球，好好感受你这二十年来的努力与热情。</p>
<a id="more"></a>
<hr>
<p>摄于2013-10-18:<br><img src="https://github.com/lizhijiang/BlogPhotos/blob/master/2013-10-18%2018.36.11.jpg?raw=true" alt=""></p>
<p>ps:科比站在罚球线上</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2013年夏天，NBA官方宣布中国赛将会在当年的10月份举行，分别有北京站和上海站共两场，湖人vs勇士。</p>
<p>那个时候大部分人还没想到勇士会达到今天的成就，但是似乎对湖人的衰落已经有所预感。</p>
<p>那一年魔兽来了又走了，纳什还未能从伤病中恢复过来，家嫂对湖人若即若离，而你，在几个月前跟腱断裂，仍然未能上场比赛。</p>
<p>然而这未能阻止那时刚刚毕业的我，买了一张接近山顶位置的票，从广州出发去到上海，并早早去到球馆检票进场。因为我相信，以你的个性，肯定会出现在赛前热身当中。</p>
<p>进场后坐下，看到库里先从勇士更衣室走出来投三分热身了，那年他还没能进全明星。湖人这边也陆续有球员出来投篮热身。果然，过了不久，球员通道附近的观众开始欢呼，你慢跑着从更衣室到了球场。全场都兴奋起来，开始齐整的叫着口号，似乎忘记了其实你并不能上场比赛。</p>
<p>你在场上待了足够长的时间，那边半场库里的三分在不停的进，伊戈还跟新人还玩起了大风车，而你只是简单地运球，投篮，半场折返跑。你还没有恢复过来，你不能起跳，不能扣篮，你甚至不能做招牌的fade away。我记得我那时候在想，一个人在受到如此严重的伤病之后，需要多大的努力，克服多大的困难，才能让自己重新回到赛场？也许只有你知道答案。终于，比赛开始的哨声响起，你慢慢的走回了更衣室，那时我看着你的背影，真有一点伤感。</p>
<p>到了今天，你宣布到了赛季结束便要退役。大家似乎已经有所准备却还是出乎意料。你说你今年打得太烂，你说你的身体已经无法继续比赛。原来真的有这么一天，你会你离开你所热爱的事物，并非热情退却，只是无能为力。</p>
<p>如果能再给我一次机会，让时间回到2013年的那个夏天，我一定尽我所能，买一张离你最近的票，安安静静的坐在场边，看着你，和那个对你来说二十年如一日的篮球，好好感受你这二十年来的努力与热情。</p>]]>
    
    </summary>
    
      <category term="词穷集" scheme="www.zhijiang.me/tags/%E8%AF%8D%E7%A9%B7%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[近期计划]]></title>
    <link href="www.zhijiang.me/2015/11/22/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/"/>
    <id>www.zhijiang.me/2015/11/22/近期计划/</id>
    <published>2015-11-22T03:51:22.000Z</published>
    <updated>2015-11-22T04:12:46.000Z</updated>
    <content type="html"><![CDATA[<p>5月中从老东家离职，9月份选择了新的公司。</p>
<p>过程非常艰难，也意识到很多不足之处。</p>
<p>总而而言，不能停止学习。</p>
<p>今年内学会一门脚本语言吧，</p>
<p>那就JavaScript吧。</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>5月中从老东家离职，9月份选择了新的公司。</p>
<p>过程非常艰难，也意识到很多不足之处。</p>
<p>总而而言，不能停止学习。</p>
<p>今年内学会一门脚本语言吧，</p>
<p>那就JavaScript吧。</p>]]>
    
    </summary>
    
      <category term="词穷集" scheme="www.zhijiang.me/tags/%E8%AF%8D%E7%A9%B7%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[影响图形性能的因素和使用Instrument进行检测]]></title>
    <link href="www.zhijiang.me/2015/08/03/%E5%BD%B1%E5%93%8D%E5%9B%BE%E5%BD%A2%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0%E5%92%8C%E4%BD%BF%E7%94%A8Instrument%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%B5%8B/"/>
    <id>www.zhijiang.me/2015/08/03/影响图形性能的因素和使用Instrument进行检测/</id>
    <published>2015-08-03T04:25:24.000Z</published>
    <updated>2015-08-13T08:55:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>性能问题是一个重大的问题。</strong></p>
<p>本文讨论的是iOS的图形性能问题。</p>
<h4 id="影响性能的因素：">影响性能的因素：</h4><p>1，<strong>CALayer的shouldRasterize(光栅化)</strong></p>
<p>这个属性看上去很不好理解，<em>光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程。光栅化的本质是坐标变换、几何离散化</em> (<a href="http://blog.csdn.net/waitforfree/article/details/10066547" target="_blank" rel="external">来源</a>)。<br><a id="more"></a><br>把layer的shouldRasterize设为YES后，CALayer会被光栅化为bitmap，layer的阴影等效果也会被保存到bitmap中作为缓存。在使用了shadow或cornerRadius等效果时，缓存使性能得到提升。</p>
<p>但是在使用这个属性前，需要明确3点：</p>
<ul>
<li>更新已经光栅化的CALayer会造成离屏渲染</li>
<li>被光栅化的bitmap如果超过100ms没有被使用则会被移除</li>
<li>系统限制缓存的大小为2.5 x screen size</li>
</ul>
<p>因此，对于经常会改动的内容，不适宜使用光栅化；对于不常使用的layer进行光栅化意义不大，而且浪费资源。</p>
<p>2，<strong>Offscreen rendering(离屏渲染)</strong></p>
<p>讨论造成离屏渲染的原因之前，先说明什么是离屏渲染：离屏渲染指的是在图像在绘制到当前屏幕前,需要先进行一次渲染,之后才绘制到当前屏幕。在第一次渲染时，GPU(Core Animation)或CPU(Core Graphics)需要额外的一块内存来进行渲染，完成后再绘制到屏幕。offscreen到onscreen需要进行上下文切换，这个切换的性能消耗是昂贵的。</p>
<p>因此，我们必须避免不必要的离屏渲染。</p>
<p>造成离屏渲染的原因有：</p>
<ul>
<li>设置CALayer的cornerRadius，edgeAntialiasingMask，allowsEdgeAntialiasing属性</li>
<li>把CALayer的maskToBounds设为YES</li>
<li>设置CALayer的shadow属性</li>
<li>设置CALayer的mask属性</li>
<li>把CALayer的allowsGroupOpacity属性设为YES而且opacity小于1</li>
</ul>
<p>等…</p>
<p>由此可见，很多常用属性都会造成离屏渲染，在性能要求高的地方，就需要使用另外的实现方案。比如使用shadowPath代替使用shadow+shadowOffset+shadowColor；在需要使用圆形图片的tableview里，使用cornerRadius设置圆角是下下之选，可以用一张中间为透明圆形的图片进行遮盖来达到圆形的效果，或者在使用前就把图片裁剪为圆形。</p>
<p>3，<strong>Blending</strong>(混合绘制)</p>
<p>GPU会放弃绘制那些完全被其他图层遮盖的内容。如果两个图层叠加在一起，上面的图层不是完全不透明的，那么GPU便会计算合并两个图层的透明重叠像素，这个过程便是blending，这同样也是一个消耗资源的过程。</p>
<p>因此，不要随便把一个视图或图层的backgroundColor设为透明。</p>
<h4 id="使用Instrument进行检查">使用Instrument进行检查</h4><p>用Xcode打开你的项目，选择工具栏上的Product-&gt;Profile，编译成功后会打开Instrument，在Choose a profile template页面下选择Core Animation，进入主界面。(如果需要检测动画帧数，需要使用真机)</p>
<p>点击左上方红色的录制按钮，开始检测：</p>
<p><img src="https://github.com/lizhijiang/BlogPhotos/blob/master/2015-08-03-1.png?raw=true" alt=""></p>
<p>在页面右下方，有一系列的复选框，利用这几个选项，我们可以很轻松的检查上面所提到的问题：(下面解释摘抄自<a href="https://www.gitbook.com/book/zsisme/ios-/details" target="_blank" rel="external">iOS核心动画高级技巧</a>第十二章)</p>
<ul>
<li><p><strong>Color Blended Layers</strong> - 这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮（也就是多个半透明图层的叠加）。由于重绘的原因，混合对GPU性能会有影响，同时也是滑动或者动画帧率下降的罪魁祸首之一。</p>
</li>
<li><p><strong>ColorHitsGreenandMissesRed</strong> - 当使用shouldRasterizep属性的时候，耗时的图层绘制会被缓存，然后当做一个简单的扁平图片呈现。当缓存再生的时候这个选项就用红色对栅格化图层进行了高亮。如果缓存频繁再生的话，就意味着栅格化可能会有负面的性能影响了。</p>
</li>
<li><p><strong>Color Copied Images</strong> - 有时候寄宿图片的生成意味着Core Animation被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说都是一项非常昂贵的操作，所以应该尽可能的避免。</p>
</li>
<li><p><strong>Color Immediately</strong> - 通常Core Animation Instruments以每毫秒10次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</p>
</li>
<li><p><strong>Color Misaligned Images</strong> - 这里会高亮那些被缩放或者拉伸以及没有正确对齐到像素边界的图片（也就是非整型坐标）。这些中的大多数通常都会导致图片的不正常缩放，如果把一张大图当缩略图显示，或者不正确地模糊图像，那么这个选项将会帮你识别出问题所在。</p>
</li>
<li><p><strong>Color Offscreen-Rendered Yellow</strong> - 这里会把那些需要离屏渲染的图层高亮成黄色。这些图层很可能需要用shadowPath或者shouldRasterize来优化。</p>
</li>
<li><p><strong>Color OpenGL Fast Path Blue</strong> - 这个选项会对任何直接使用OpenGL绘制的图层进行高亮。如果仅仅使用UIKit或者Core Animation的API，那么不会有任何效果。如果使用GLKView或者CAEAGLLayer，那如果不显示蓝色块的话就意味着你正在强制CPU渲染额外的纹理，而不是绘制到屏幕。</p>
</li>
<li><p><strong>Flash Updated Regions</strong> - 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。</p>
</li>
</ul>
<p>需要注意的重点是这3个：</p>
<p><em>Color Blended Layers</em> </p>
<p>勾选后，检查你的应用界面，blended layer会显示为红色，不透明的为绿色，红色越少越好，如果你的界面一片红海，那就是时候好好优化了。</p>
<p><em>ColorHitsGreenandMissesRed</em></p>
<p>勾选后，如果在你使用了shouldRasterize的地方界面显示为绿色，则表示使用正确性能良好，如果为红色，则需要考虑优化了。(第一次加载时会显示红色，因为这时还没缓存成功，需要检测重用的过程中(比如tableview上下滚动)的变化)</p>
<p><em>Color Offscreen-Rendered Yellow</em></p>
<p>如上所述，离屏渲染的地方都标记为黄色。并非所有的黄色区域都是需要优化的，比如UINavigationBar，因为需要做背景模糊效果，因此它需要离屏渲染。</p>
<h4 id="总结">总结</h4><p>不会写总结</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>性能问题是一个重大的问题。</strong></p>
<p>本文讨论的是iOS的图形性能问题。</p>
<h4 id="影响性能的因素：">影响性能的因素：</h4><p>1，<strong>CALayer的shouldRasterize(光栅化)</strong></p>
<p>这个属性看上去很不好理解，<em>光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程。光栅化的本质是坐标变换、几何离散化</em> (<a href="http://blog.csdn.net/waitforfree/article/details/10066547">来源</a>)。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="www.zhijiang.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer初探]]></title>
    <link href="www.zhijiang.me/2015/06/19/CALayer%E5%88%9D%E6%8E%A2/"/>
    <id>www.zhijiang.me/2015/06/19/CALayer初探/</id>
    <published>2015-06-19T07:42:36.000Z</published>
    <updated>2015-06-19T06:32:41.000Z</updated>
    <content type="html"><![CDATA[<p>今天要谈的是CALayer。</p>
<p>如果你是一个iOS开发者，那么我相信你一定对UIView已经非常熟悉，UIButton，UILabel，UITextView…几乎开发每一个iOS app都会跟UIView及其子类甚至是自定义的UIView打交道。而UIView下面所包含的CALayer，可能很多刚入门iOS的开发者对它并不是很熟悉，也很少在实际开发中使用它，但我们必须对它有所了解，因为它可以帮助我们简单地实现一些图形变换，并且对了解Core Animation至关重要。</p>
<p>在了解CALayer之前，先了解它跟UIView的关系：</p>
<p>引自StarkOverFlow的一个<a href="http://stackoverflow.com/questions/7826306/what-are-the-differences-between-a-uiview-and-a-calayer" target="_blank" rel="external">答案</a>：</p>
<blockquote>
<p>On iOS, every UIView is backed by a Core Animation CALayer, so you are dealing with CALayers when using a UIView, even though you may not realize it. Unlike NSViews on the Mac, which evolved before Core Animation existed, UIViews are intended to be lightweight wrappers around these CALayers.</p>
<p>Working directly with CALayers doesn’t give you significant  performance advantages over UIViews. One of the reasons you might want to build a user interface element with CALayers instead of UIViews is that it can be very easily ported to the Mac. UIViews are very different from NSViews, but CALayers are almost identical on the two platforms. This is why the Core Plot framework lays out its graphs using CALayers instead of other UI elements.</p>
<p>One thing UIViews provide over CALayers is built-in support for user interaction. They handle hit-testing on touches and other related actions that you would need to build yourself if managing a hierarchy of CALayers. It’s not that hard to implement this yourself, but it is extra code you’d need to write when building a CALayer-only interface.</p>
<p>You will often need to access the underlying layers for a UIView when performing more complex animations than the base UIView class allows. UIView’s animation capabilities have grown as the iOS SDK has matured, but there are still a few things that are best done by interacting with the underlying CALayer.</p>
</blockquote>
<p>这里指出了几个重要的点：<br><a id="more"></a><br>1，UIView是CALayer的一层轻量级的封装，当你使用UIView的时候便是在与CALayer打交道。</p>
<p>2，直接使用CALayer替代UIView并不会给你带来明显的性能提升。</p>
<p>3，UIView提供了CAlayer所没有的处理用户交互的能力。</p>
<p>4，当你想要实现一些复杂的动画的时候，访问UIView底层的CALayer将会很有帮助。</p>
<p><br><br>我相信上面4点已经可以解答大部分人原本对这两者关系的疑惑了。</p>
<p>CALayer类在概念上和UIView类似，同样也是被层级关系树管理的矩形块，同样也可以包含一些内容(像图片，文本或者背景色)，管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。</p>
<p>我们看看官方对CALayer的描述：(摘自<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/" target="_blank" rel="external">Apple官方文档</a>)</p>
<blockquote>
<p>The CALayer class manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content. A layer’s main job is to manage the visual content that you provide but the layer itself has visual attributes that can be set, such as a background color, border, and shadow. In addition to managing visual content, the layer also maintains information about the geometry of its content (such as its position, size, and transform) that is used to present that content onscreen. </p>
</blockquote>
<p>(不翻译了词穷…)</p>
<p>每一个UIView底下都有一个CALayer，可以通过访问它的layer属性获取：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">CALayer </span>*layer = <span class="keyword">self</span>.view.layer;</span><br></pre></td></tr></table></figure>
<p>也可以手动创建一个CALayer，可以添加subLayer：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CALayer *subLayer </span>=<span class="string"> [CALayer layer];</span><br><span class="line">[layer addSubLayer:subLayer];</span></span><br></pre></td></tr></table></figure>
<p>CALayer有下列一系列的属性：</p>
<ul>
<li>frame</li>
<li>background color</li>
<li>contents</li>
<li>corners</li>
<li>shadow</li>
<li>border</li>
<li>…</li>
</ul>
<p>为了更清晰地了解CALayer，让我们新建一个Demo项目来测试CALayer的各个属性。</p>
<p>首先试着新建一个简单的CALayer并设置其背景颜色。新建一个single view application，在root viewcontroller的viewDidiLoad里添加如下代码：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CALayer *<span class="variable">layer =</span> self.view.layer;</span><br><span class="line">layer.<span class="variable">backgroundColor =</span> [UIColor greenColor].CGColor;</span><br><span class="line"></span><br><span class="line">CALayer *<span class="variable">subLayer =</span> [CALayer layer];</span><br><span class="line">subLayer.<span class="variable">frame =</span> CGRectMake(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">subLayer.<span class="variable">backgroundColor =</span> [UIColor redColor].CGColor;</span><br><span class="line">[layer addSublayer:subLayer];</span><br></pre></td></tr></table></figure>
<p>设置圆角：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALayer *<span class="variable">cornerLayer =</span> [CALayer layer];</span><br><span class="line">cornerLayer.<span class="variable">frame =</span> CGRectMake(<span class="number">160</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">cornerLayer.<span class="variable">backgroundColor =</span> [UIColor blueColor].CGColor;</span><br><span class="line">cornerLayer.<span class="variable">cornerRadius =</span> <span class="number">10</span>;</span><br><span class="line">[layer addSublayer:cornerLayer];</span><br></pre></td></tr></table></figure>
<p>run：</p>
<p><img src="https://github.com/lizhijiang/CALayerDemo/blob/master/screenshot/1.png?raw=true =300x" alt=""></p>
<p>设置阴影：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CALayer *<span class="variable">shadowLayer =</span> [CALayer layer];</span><br><span class="line">shadowLayer.<span class="variable">frame =</span> CGRectMake(<span class="number">50</span>, <span class="number">160</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">shadowLayer.<span class="variable">backgroundColor =</span> [UIColor yellowColor].CGColor;</span><br><span class="line">shadowLayer.<span class="variable">shadowOffset =</span> CGSizeMake(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">shadowLayer.<span class="variable">shadowColor =</span> [UIColor blackColor].CGColor;</span><br><span class="line">shadowLayer.<span class="variable">shadowRadius =</span> <span class="number">5</span>;</span><br><span class="line">shadowLayer.<span class="variable">shadowOpacity =</span> <span class="number">1</span>;</span><br><span class="line">[layer addSublayer:shadowLayer];</span><br></pre></td></tr></table></figure>
<p>设置边界颜色：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CALayer *<span class="variable">borderLayer =</span> [CALayer layer];</span><br><span class="line">borderLayer.<span class="variable">frame =</span> CGRectMake(<span class="number">160</span>, <span class="number">160</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">borderLayer.<span class="variable">backgroundColor =</span> [UIColor orangeColor].CGColor;</span><br><span class="line">borderLayer.<span class="variable">borderColor =</span> [UIColor grayColor].CGColor;</span><br><span class="line">borderLayer.<span class="variable">borderWidth =</span> <span class="number">4</span>.f;</span><br><span class="line">[layer addSublayer:borderLayer];</span><br></pre></td></tr></table></figure>
<p>run：</p>
<p><img src="https://github.com/lizhijiang/CALayerDemo/blob/master/screenshot/2.png?raw=true =300x" alt=""></p>
<p>设置背景图片：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CALayer *<span class="variable">imageContentLayer =</span> [CALayer layer];</span><br><span class="line">imageContentLayer.<span class="variable">frame =</span> CGRectMake(<span class="number">50</span>, <span class="number">270</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">imageContentLayer.<span class="variable">contents =</span> (id)[UIImage imageNamed:@<span class="string">"image.png"</span>].CGImage;</span><br><span class="line">[layer addSublayer:imageContentLayer];</span><br></pre></td></tr></table></figure>
<p>蒙版(mask)：通过设置蒙版，可以把view裁剪成特定的形状</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *<span class="variable">imageView =</span> [[UIImageView alloc] initWithFrame:frame];</span><br><span class="line">imageView.<span class="variable">image =</span> [UIImage imageNamed:@<span class="string">"test.png"</span>];</span><br><span class="line"></span><br><span class="line">CALayer *<span class="variable">maskLayer =</span> [CALayer layer];</span><br><span class="line">maskLayer.<span class="variable">frame =</span> imageView.bounds;</span><br><span class="line">maskLayer.<span class="variable">contents =</span> (id)[UIImage imageNamed:@<span class="string">"weibo.png"</span>].CGImage;</span><br><span class="line"></span><br><span class="line">imageView.layer.<span class="variable">mask =</span> maskLayer;</span><br><span class="line">[self.view addSubview:imageView];</span><br></pre></td></tr></table></figure>
<p>run：</p>
<p><img src="https://github.com/lizhijiang/CALayerDemo/blob/master/screenshot/3.png?raw=true =300x" alt=""></p>
<p>这些CALayer属性，同时也能作用于CALayer上的UIView(很多时候我们希望给UIImageView设置圆角便是通过访问UIImageView的layer设置它的cornerRaduis来达到目的)。</p>
<p>有过Android开发经验的同学此时一定会感觉到，这真TM太方便了！寥寥数行代码就可以实现圆角和阴影等。但是CALayer可以做的绝不止于此。</p>
<h4 id="自定义绘制">自定义绘制</h4><p>如果你希望自己绘制layer的内容，你只需设置CALayer的delegate，然后委托的对象实现drawLayer:inContext方法，在该方法里编写绘制内容的代码：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALayer *<span class="variable">customLayer =</span> [CALayer layer];</span><br><span class="line">customLayer.<span class="variable">frame =</span> CGRectMake(<span class="number">50</span>, <span class="number">380</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">customLayer.<span class="variable">backgroundColor =</span> [UIColor whiteColor].CGColor;</span><br><span class="line">customLayer.<span class="variable">delegate =</span> self;</span><br><span class="line">[layer addSublayer:customLayer];</span><br></pre></td></tr></table></figure>
<p>我们尝试在上面画一个圆：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>drawLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer inContext:<span class="params">(<span class="variable">CGContextRef</span>)</span>ctx &#123;</span><br><span class="line">    CGContextSetLineWidth<span class="params">(ctx, <span class="number">2.0</span>f)</span>;</span><br><span class="line">    CGContextSetStrokeColorWithColor<span class="params">(ctx, [<span class="variable">UIColor</span> red<span class="variable">Color</span>].<span class="variable">CGColor</span>)</span>;</span><br><span class="line">    CGContextStrokeEllipseInRect<span class="params">(ctx, layer.bounds)</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后，需要调用<code>[customLayer setNeedsDisplay]</code>告诉layer对象刷新内容，否则整个绘制方法将不会调用。</p>
<p>run：</p>
<p><img src="https://github.com/lizhijiang/CALayerDemo/blob/master/screenshot/4.png?raw=true =300x" alt=""></p>
<h4 id="专用图层">专用图层</h4><p>Apple提供了一系列的专用图层来帮助开发者来实现一些不同的效果。CAGradientLayer可以轻易地实现颜色的渐变，CATextLayer可以较容易地实现一些富文本的显示，还有CAShapeLayer，AVPlayerLayer等，这些在日后的文章再慢慢了解。</p>
<p>demo下载地址：<a href="">https://github.com/lizhijiang/CALayerDemo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天要谈的是CALayer。</p>
<p>如果你是一个iOS开发者，那么我相信你一定对UIView已经非常熟悉，UIButton，UILabel，UITextView…几乎开发每一个iOS app都会跟UIView及其子类甚至是自定义的UIView打交道。而UIView下面所包含的CALayer，可能很多刚入门iOS的开发者对它并不是很熟悉，也很少在实际开发中使用它，但我们必须对它有所了解，因为它可以帮助我们简单地实现一些图形变换，并且对了解Core Animation至关重要。</p>
<p>在了解CALayer之前，先了解它跟UIView的关系：</p>
<p>引自StarkOverFlow的一个<a href="http://stackoverflow.com/questions/7826306/what-are-the-differences-between-a-uiview-and-a-calayer">答案</a>：</p>
<blockquote>
<p>On iOS, every UIView is backed by a Core Animation CALayer, so you are dealing with CALayers when using a UIView, even though you may not realize it. Unlike NSViews on the Mac, which evolved before Core Animation existed, UIViews are intended to be lightweight wrappers around these CALayers.</p>
<p>Working directly with CALayers doesn’t give you significant  performance advantages over UIViews. One of the reasons you might want to build a user interface element with CALayers instead of UIViews is that it can be very easily ported to the Mac. UIViews are very different from NSViews, but CALayers are almost identical on the two platforms. This is why the Core Plot framework lays out its graphs using CALayers instead of other UI elements.</p>
<p>One thing UIViews provide over CALayers is built-in support for user interaction. They handle hit-testing on touches and other related actions that you would need to build yourself if managing a hierarchy of CALayers. It’s not that hard to implement this yourself, but it is extra code you’d need to write when building a CALayer-only interface.</p>
<p>You will often need to access the underlying layers for a UIView when performing more complex animations than the base UIView class allows. UIView’s animation capabilities have grown as the iOS SDK has matured, but there are still a few things that are best done by interacting with the underlying CALayer.</p>
</blockquote>
<p>这里指出了几个重要的点：<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="www.zhijiang.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用MacVim代替系统内置Vim]]></title>
    <link href="www.zhijiang.me/2015/04/07/%E4%BD%BF%E7%94%A8MacVim%E4%BB%A3%E6%9B%BF%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AEVim/"/>
    <id>www.zhijiang.me/2015/04/07/使用MacVim代替系统内置Vim/</id>
    <published>2015-04-06T17:55:26.000Z</published>
    <updated>2015-11-22T04:12:57.000Z</updated>
    <content type="html"><![CDATA[<p>在配置Rails的Vim环境的时候，发现OS X内置的Vim版本是7.3，YouCompleteMe插件提示需要Vim7.4，于是很自然地Google一下，得到的答案是，大多数人的建议是保留内置的Vim，另外安装7.4的在机器上(我也十分认同，毕竟任何对build in内容的修改可能会导致不可修复的问题，或者在系统更新的时候把自己的配置覆盖掉)。于是MacVim就成了最好的选择。</p>
<p><a href="https://code.google.com/p/macvim/" target="_blank" rel="external">MacVim介绍与下载</a></p>
<p>下载后把MacVim.app文件复制到Applications目录下，在LaunchPad里就能直接启动MacVim了，但是到这里跟预期还是有所出入，在终端内启动Vim，还是内置的Vim，对于常用终端的人来说，使用MacVim需要另外多开一个窗口，显得十分不便。当然，解决方法自然是有的，想要在终端里用MacVim代替内置的Vim，要在.profile里设置别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> vim=<span class="string">'/Applications/MacVim.app/Contents/MacOS/Vim'</span></span><br></pre></td></tr></table></figure>
<p>保存后记得执行一下<code>source .profile</code>使修改生效。</p>
<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<p>在配置Rails的Vim环境的时候，发现OS X内置的Vim版本是7.3，YouCompleteMe插件提示需要Vim7.4，于是很自然地Google一下，得到的答案是，大多数人的建议是保留内置的Vim，另外安装7.4的在机器上(我也十分认同，毕竟任何对build in内容的修改可能会导致不可修复的问题，或者在系统更新的时候把自己的配置覆盖掉)。于是MacVim就成了最好的选择。</p>
<p><a href="https://code.google.com/p/macvim/">MacVim介绍与下载</a></p>
<p>下载后把MacVim.app文件复制到Applications目录下，在LaunchPad里就能直接启动MacVim了，但是到这里跟预期还是有所出入，在终端内启动Vim，还是内置的Vim，对于常用终端的人来说，使用MacVim需要另外多开一个窗口，显得十分不便。当然，解决方法自然是有的，想要在终端里用MacVim代替内置的Vim，要在.profile里设置别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> vim=<span class="string">'/Applications/MacVim.app/Contents/MacOS/Vim'</span></span><br></pre></td></tr></table></figure>
<p>保存后记得执行一下<code>source .profile</code>使修改生效。</p>]]>
    
    </summary>
    
      <category term="Tools" scheme="www.zhijiang.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Toolbar使用注意事项]]></title>
    <link href="www.zhijiang.me/2015/03/30/Android-Toolbar%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>www.zhijiang.me/2015/03/30/Android-Toolbar使用注意事项/</id>
    <published>2015-03-30T09:49:47.000Z</published>
    <updated>2015-03-31T14:45:03.000Z</updated>
    <content type="html"><![CDATA[<p>赶在了愚人节前完成了自己的第一篇关于编程的blog，似乎…也没什么特别的…<br><br>只是希望在这之后，能克服自己的惰性，完成下个目标吧。</p>
<p>最近在新项目中要求设计师参考Material Design来设计新的UI, 于是在开发过程中用上了不少Android 5.0的新特性，实际用起来也是挺爽的，甚至让我有重回Android怀抱的冲动。同时因为对5.0的API还不熟悉，想着或许写作技术总结的文章会对加深理解和纠正错误有所帮助，所以便有了这个。<br></p>
<h5 id="这篇是总结Toolbar的用法。">这篇是总结Toolbar的用法。</h5><p>因为项目要兼容到Android4.0, 所以使用support v7的兼容包进行开发，IDE用的是Android Studio, 使用gradle构建项目。<br><a id="more"></a></p>
<h3 id="添加依赖库:">添加依赖库:</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">   <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:21.0.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置styles-xml:">设置styles.xml:</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="property">name</span>=<span class="string">"AppTheme.Base"</span> parent=<span class="string">"Theme.AppCompat.Light"</span>&gt;</span><br><span class="line">       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"windowActionBar"</span>&gt;<span class="constant">false</span>&lt;/<span class="property">item</span>&gt;</span><br><span class="line">       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowNoTitle"</span>&gt;<span class="constant">true</span>&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p> 网上有的教程是把parent设为 Theme.AppCompat.Light.NoActionBar, 这样的话调用 setSupportActionBar(toolbar) 就会报错, 正确的方法是使用 Theme.AppCompat 或者 Theme.AppCompat.Light , 然后设置 windowActionBar 的属性为false,  android:windowNoTitle 属性为true。</p>
<h3 id="编写layout:">编写layout:</h3><p>Toolbar的使用非常简单，只需要在layout文件中添加对应的layout控件，再通过findViewById方法即可获得Toolbar对象：</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.Toolbar</span></span><br><span class="line">  android:id=<span class="string">"@+id/toolbar"</span></span><br><span class="line">  android:layout_height=<span class="string">"?attr/actionBarSize"</span></span><br><span class="line">  android:layout_width=<span class="string">"match_parent"</span> &gt;</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.Toolbar</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="取得Toolbar:">取得Toolbar:</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Toolbar toolbar = (Toolbar) findViewById(R.<span class="property">id</span>.toolbar);</span><br><span class="line">setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure>
<p>这里通过调用setSupportActionBar, 对ActionBar的设置都会把相应的属性设置到Toolbar上，这里要注意一个问题，setSupportActionBar后，Toolbar的inflateMenu(int resId)方法会失效，需要像ActionBar一样实现Activity的onCreateOptionsMenu(Menu menu)方法才能正确显示菜单。当然不调用setSupportActionBar也是没有问题的，Toolbar的设计是可以使用在任何地方。</p>
<h3 id="Toolbar属性设置:">Toolbar属性设置:</h3><p>这里总结一下Toolbar常用的一些属性, 主要是开发过程中比较容易引起迷惑的一些地方。</p>
<h5 id="状态栏背景色:">状态栏背景色:</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;@color/statusbar_color&lt;/<span class="property">item</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这是Android5.0后才有的属性, 参考了iOS7的设计，状态栏的颜色也可以设置了，不过根据笔者经验，Material Design下的状态栏颜色和Toolbar颜色一般是不一样的，状态栏的颜色一般会深一点。</p>
<h5 id="Toolbar颜色:">Toolbar颜色:</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"colorPrimary"</span>&gt;@color/toolbar_color&lt;/<span class="property">item</span>&gt;</span><br></pre></td></tr></table></figure>
<h5 id="标题，NavigationIcon,_Menu_Icon的颜色:">标题，NavigationIcon, Menu Icon的颜色:</h5><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=<span class="string">"android:textColorSecondary"</span>&gt;<span class="variable">@android</span><span class="symbol">:color/white&lt;/item&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个有点类似与iOS的UINavigationBar的tintColor属性，设置后NavigationIcon和Menu Icon的颜色都会改变(图片是要alpha通道的)。</p>
<h5 id="Menu文字的颜色:">Menu文字的颜色:</h5><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=<span class="string">"actionMenuTextColor"</span>&gt;<span class="variable">@android</span><span class="symbol">:color/white&lt;/item&gt;</span></span><br></pre></td></tr></table></figure>
<p> 菜单文字的颜色是单独设置的，这也是需要注意的地方。<br></p>
<h5 id="使用:">使用:</h5> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="property">name</span>=<span class="string">"ToolBarTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><br><span class="line">       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"colorPrimary"</span>&gt;@color/toolbar_bg&lt;/<span class="property">item</span>&gt;</span><br><span class="line">       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:textColorPrimary"</span>&gt;@android:color/black&lt;/<span class="property">item</span>&gt;</span><br><span class="line">       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:textColorSecondary"</span>&gt;@android:color/white&lt;/<span class="property">item</span>&gt;</span><br><span class="line">       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"actionMenuTextColor"</span>&gt;@android:color/white&lt;/<span class="property">item</span>&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.Toolbar</span></span><br><span class="line">        xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">        xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">        android:id=<span class="string">"@+id/toolbar"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:minHeight=<span class="string">"?attr/actionBarSize"</span></span><br><span class="line">        app:theme=<span class="string">"@style/ToolBarTheme"</span> &gt;</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.Toolbar</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="参考文档：">参考文档：</h4><p><a href="http://developer.android.com/reference/android/support/v7/widget/Toolbar.html" target="_blank" rel="external">http://developer.android.com/reference/android/support/v7/widget/Toolbar.html</a><br><a href="http://blog.mosil.biz/2014/10/android-toolbar/" target="_blank" rel="external">http://blog.mosil.biz/2014/10/android-toolbar/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>赶在了愚人节前完成了自己的第一篇关于编程的blog，似乎…也没什么特别的…<br /><br>只是希望在这之后，能克服自己的惰性，完成下个目标吧。</p>
<p>最近在新项目中要求设计师参考Material Design来设计新的UI, 于是在开发过程中用上了不少Android 5.0的新特性，实际用起来也是挺爽的，甚至让我有重回Android怀抱的冲动。同时因为对5.0的API还不熟悉，想着或许写作技术总结的文章会对加深理解和纠正错误有所帮助，所以便有了这个。<br /></p>
<h5 id="这篇是总结Toolbar的用法。">这篇是总结Toolbar的用法。</h5><p>因为项目要兼容到Android4.0, 所以使用support v7的兼容包进行开发，IDE用的是Android Studio, 使用gradle构建项目。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="www.zhijiang.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy Chinese new year!]]></title>
    <link href="www.zhijiang.me/2015/02/18/Happy-Chinese-new-year/"/>
    <id>www.zhijiang.me/2015/02/18/Happy-Chinese-new-year/</id>
    <published>2015-02-18T12:05:36.000Z</published>
    <updated>2015-02-18T12:06:55.000Z</updated>
    <content type="html"><![CDATA[<p>羊年进步！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>羊年进步！</p>
]]>
    </summary>
    
  </entry>
  
</feed>
